{
  "version": 3,
  "sources": ["browser-external:fs", "../../.pnpm/db-local@3.1.0/node_modules/db-local/lib/utils.js", "../../.pnpm/db-local@3.1.0/node_modules/db-local/lib/modules/methods.js", "../../.pnpm/db-local@3.1.0/node_modules/db-local/lib/modules/objectid.js", "browser-external:path", "../../.pnpm/db-local@3.1.0/node_modules/db-local/lib/modules/schema.js", "../../.pnpm/db-local@3.1.0/node_modules/db-local/lib/index.js"],
  "sourcesContent": ["module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"fs\" has been externalized for browser compatibility. Cannot access \"fs.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "const { writeFileSync } = require('fs');\r\n\r\n/**\r\n * Returns the class of a value.\r\n * @param {*} value - The value to be verified.\r\n * @returns {string} The value class.\r\n */\r\nfunction getInstance(value) {\r\n  const type = typeof value;\r\n\r\n  return type === 'object' || type === 'function'\r\n    ? Object.prototype.toString.call(value).slice(8, -1).toLowerCase()\r\n    : type;\r\n}\r\n\r\n/**\r\n * Check if the values of an object are in accordance with a defined scheme.\r\n * @param {object} obj - The object to be verified.\r\n * @param {object} schema - The scheme to be used to verify the object.\r\n * @returns {object} An object with the values of the object verified, following the defined scheme.\r\n * @throws {Error} If a required value is absent or not in accordance with the scheme.\r\n */\r\nfunction verifySchema(obj, schema) {\r\n  const defined = {};\r\n\r\n  for (const [key, data] of Object.entries(schema)) {\r\n    const value = obj?.[key];\r\n    const type = typeof data === 'function' ? data : data?.type || data;\r\n\r\n    if (!type)\r\n      throw new Error(`The value \"${key}\" does not have a defined type.`);\r\n\r\n    const instanceOfValue = getInstance(value);\r\n    const instanceOfType = getInstance(type);\r\n    const instanceOfTypeFunction =\r\n      instanceOfType === 'function' && getInstance(type());\r\n\r\n    if (['null', 'undefined'].includes(instanceOfType))\r\n      throw new Error(`The value \"${key}\" has an invalid type.`);\r\n\r\n    const hasDefault = data?.default !== undefined;\r\n    const hasNullable = data?.nullable !== undefined;\r\n    const isUndefinedOrNull = ['undefined', 'null'].includes(instanceOfValue);\r\n\r\n    if (instanceOfValue === 'undefined') {\r\n      if (!hasDefault && data?.required)\r\n        throw new Error(`The value \"${key}\" is required.`);\r\n\r\n      if (hasDefault)\r\n        defined[key] =\r\n          typeof data.default === 'function' ? data.default() : data.default;\r\n      else defined[key] = undefined;\r\n\r\n      continue;\r\n    }\r\n\r\n    if (instanceOfValue === 'null' && !hasNullable)\r\n      throw new Error(`The value \"${key}\" cannot be null.`);\r\n\r\n    if (data?.enum && !data.enum.includes(value))\r\n      throw new Error(\r\n        `The value \"${key}\" must be one of the following values: ${data.enum.join(\r\n          ', '\r\n        )}.`\r\n      );\r\n\r\n    switch (instanceOfType) {\r\n      case 'function': {\r\n        if (\r\n          instanceOfTypeFunction &&\r\n          instanceOfValue !== instanceOfTypeFunction\r\n        )\r\n          throw new Error(\r\n            `The value \"${key}\" must be an instance of ${type.name}.`\r\n          );\r\n        else defined[key] = value;\r\n        break;\r\n      }\r\n      case 'object': {\r\n        if (!isUndefinedOrNull) defined[key] = verifySchema(value, type);\r\n        break;\r\n      }\r\n      case 'array': {\r\n        if (instanceOfValue === 'array')\r\n          defined[key] = value.map(item => {\r\n            const instanceOfItem = getInstance(item);\r\n            const instanceOfTypeItem = getInstance(\r\n              typeof type[0] === 'function' ? type[0]() : type[0]?.type()\r\n            );\r\n\r\n            if (instanceOfItem === 'object') return verifySchema(item, type[0]);\r\n\r\n            if (instanceOfItem !== instanceOfTypeItem && !type[0]?.nullable)\r\n              throw new Error(\r\n                `The value \"${key}\" must be an Array of the type ${instanceOfTypeItem} and has received a item of type ${instanceOfItem}.`\r\n              );\r\n\r\n            return item;\r\n          });\r\n        break;\r\n      }\r\n      default: {\r\n        if (instanceOfValue !== instanceOfType)\r\n          throw new Error(\r\n            `The value \"${key}\" must be an instance of ${instanceOfType}.`\r\n          );\r\n\r\n        defined[key] = value;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return defined;\r\n}\r\n\r\n/**\r\n * It takes an object, an object of entries, and a schema, and returns an object with the entries\r\n * merged into the object, and verified against the schema.\r\n * @param obj - The object to be concatenated\r\n * @param entries - The object you want to merge with the original object.\r\n * @param schema - The schema to use to verify the entries.\r\n * @returns the result of the verifySchema function.\r\n */\r\nfunction concat(obj, entries, schema) {\r\n  const defined = { ...obj };\r\n\r\n  Object.entries(entries).forEach(r => {\r\n    Object.entries(defined).filter(a => {\r\n      if (a[0] === r[0] && r[1] != a[1]) defined[a[0]] = r[1];\r\n      else if (r[0]) defined[r[0]] = r[1];\r\n    });\r\n  });\r\n\r\n  return verifySchema(defined, schema);\r\n}\r\n\r\n/**\r\n * \"Given an object and a string, return the value of the object's property that matches the string.\"\r\n *\r\n * The function takes two arguments:\r\n *\r\n * obj: The object to search.\r\n * string: The string to search for.\r\n * The function returns the value of the object's property that matches the string\r\n * @param obj - The object to search\r\n * @param string - The string to use to get the properties.\r\n */\r\nconst getPropertiesByString = (obj, string) =>\r\n  string.split('.').reduce((o, i) => o?.[i], obj);\r\n\r\n/**\r\n * It takes an array of objects and an object of operators and returns the filtered array of objects\r\n * @param data - The data you want to filter\r\n * @param operators - The operators you want to use to filter the data\r\n * @returns The data that matches the operators.\r\n */\r\nfunction filterWithOperator(data, operators) {\r\n  const props = (...args) => getPropertiesByString(...args);\r\n\r\n  if (!data) return null;\r\n\r\n  const filters = {\r\n    $gt: (obj, key, value) => props(obj, key) > value,\r\n    $lt: (obj, key, value) => props(obj, key) < value,\r\n    $gte: (obj, key, value) => props(obj, key) >= value,\r\n    $lte: (obj, key, value) => props(obj, key) <= value,\r\n    $eq: (obj, key, value) => props(obj, key) === value,\r\n    $neq: (obj, key, value) => props(obj, key) !== value,\r\n    $in: (obj, key, value) => {\r\n      if(Array.isArray(value)) return value.some(a => props(obj, key).includes(a))\r\n      else return props(obj, key).includes(value);\r\n    },\r\n    $nin: (obj, key, value) => {\r\n      if(Array.isArray(value)) return value.every(a => !props(obj, key).includes(a))\r\n      else return !props(obj, key).includes(value);\r\n    },\r\n    $regex: (obj, key, value) => props(obj, key).match(value),\r\n    $exists: (obj, key) => props(obj, key) !== undefined\r\n  };\r\n\r\n  const limit = operators?.$limit;\r\n\r\n  operators = Object.keys(operators)\r\n    .filter(a => !['$id', '$ref'].includes(a))\r\n    .reduce((acc, key) => {\r\n      const data = operators[key];\r\n\r\n      for (const operator in data) {\r\n        const value = data[operator];\r\n\r\n        if (\r\n          value &&\r\n          filters[operator] && (typeof value === 'object' ? Array.isArray(value) : true)\r\n        )\r\n          acc.push({ operator, value, key });\r\n      }\r\n\r\n      return acc;\r\n    }, []);\r\n\r\n  for (var filter of operators) {\r\n    const { operator, value, key } = filter;\r\n    data = data.filter(obj => filters[operator](obj, key, value));\r\n  }\r\n\r\n  if (typeof limit === 'number' && limit >= 1) {\r\n    if (!Array.isArray(data)) data = [data];\r\n\r\n    if (limit === 1) {\r\n      if (data.length) return data[0];\r\n      else return null;\r\n    } else return data.slice(0, limit);\r\n  } else {\r\n    return data;\r\n  }\r\n}\r\n\r\n/**\r\n * It returns an object with two properties, data and rest. The data property contains all the\r\n * operators in the object, and the rest property contains all the non-operators\r\n * @returns An object with two properties: data and rest.\r\n */\r\nfunction filterOperators(data) {\r\n  const filter = index => {\r\n    const notOperators = ['$id', '$ref'];\r\n    const customOperators = ['$limit'];\r\n    if (\r\n      notOperators.includes(index) ||\r\n      !['object', 'string'].includes(typeof data)\r\n    )\r\n      return false;\r\n\r\n    if (customOperators.includes(index)) return true;\r\n    else if (typeof data[index] === 'string') return data[index].includes('$');\r\n    else if (typeof data[index] === 'object')\r\n      return Object.keys(data[index]).some(\r\n        index => index.includes('$') && !notOperators.includes(index)\r\n      );\r\n  };\r\n\r\n  if (typeof data !== 'object')\r\n    return {\r\n      data: false,\r\n      rest: data\r\n    };\r\n\r\n  const operators = Object.keys(data).filter(filter);\r\n  const notOperators = Object.keys(data).filter(index => !filter(index));\r\n\r\n  const result = {\r\n    data: operators.length ? {} : false,\r\n    rest: notOperators.length ? {} : false\r\n  };\r\n\r\n  for (var operator of operators) result.data[operator] = data[operator];\r\n  for (var rest of notOperators) result.rest[rest] = data[rest];\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * It takes an object, a schema, and a base data object, and returns an object with the same keys as\r\n * the original object, but with the values replaced with the data from the schema\r\n * @param obj - The object that contains the references\r\n * @param schemas - The schemas object\r\n * @param baseData - The data that will be used to find the references\r\n * @returns An object with the key being the name of the property and the value being the data.\r\n */\r\nfunction checkObjectReferences(obj, schemas, baseData) {\r\n  const defined = {};\r\n\r\n  for (const key of Object.keys(obj)) {\r\n    if (obj[key]?.$ref && obj[key]?.$id) {\r\n      const { $id, $ref } = obj[key];\r\n      const refSchema = schemas[$ref];\r\n      const model = read(refSchema.path);\r\n      let propertyRef, data;\r\n\r\n      const multipleFind = obj =>\r\n        Array.isArray(propertyRef)\r\n          ? propertyRef.includes(obj._id)\r\n          : obj._id === propertyRef;\r\n\r\n      const defaultAction = id => model.find(obj => obj._id === id);\r\n\r\n      if (!refSchema) throw new Error(`The \"${$ref}\" schema is not defined`);\r\n\r\n      if (\r\n        typeof $id === 'number' ||\r\n        (typeof $id === 'string' && !$id.includes('$data'))\r\n      ) {\r\n        data = defaultAction($id);\r\n      } else {\r\n        propertyRef = getPropertiesByString(\r\n          baseData,\r\n          typeof $id === 'string' ? $id?.replace('$data.', '') : $id.$data\r\n        );\r\n\r\n        data =\r\n          model[Array.isArray(propertyRef) ? 'filter' : 'find'](multipleFind);\r\n      }\r\n\r\n      const operators = filterOperators(obj[key]);\r\n\r\n      defined[key] = operators.data\r\n        ? filterWithOperator(data, operators.data)\r\n        : data;\r\n    }\r\n  }\r\n\r\n  return defined;\r\n}\r\n\r\n/**\r\n * It takes an object and a set of properties, and then creates those properties on the object\r\n * @param data - The object you want to add the properties to.\r\n * @param properties - An object containing the properties to be added to the data object.\r\n * @returns The data object with the properties added to it.\r\n */\r\nfunction createProperties(data, properties) {\r\n  const getPropertyConfig = val => ({\r\n    get: () => val,\r\n    enumerable: false,\r\n    configurable: true\r\n  });\r\n\r\n  for (var property of Object.entries(properties)) {\r\n    const [key, value] = property;\r\n    const valueType = getInstance(value);\r\n\r\n    if (valueType === 'function')\r\n      properties[key] = getPropertyConfig(value.bind(data));\r\n    else properties[key] = getPropertyConfig(value);\r\n  }\r\n\r\n  Object.defineProperties(data, properties);\r\n\r\n  return data;\r\n}\r\n\r\n/**\r\n * It reads a file and returns the contents of the file.\r\n * @param path - The path to the file you want to read.\r\n * @param clear - If true, the module will be reloaded.\r\n * @returns The function read is being returned.\r\n */\r\nconst read = (path, clear) => {\r\n  if (clear) delete require.cache[require.resolve(path)];\r\n  return require(path);\r\n};\r\n\r\n/**\r\n * It takes a path and content, writes the content to the path, and returns the content\r\n * @param path - The path to the file you want to save.\r\n * @param content - The content to be saved.\r\n * @returns The content.\r\n */\r\nconst save = (path, content) => {\r\n  writeFileSync(path, JSON.stringify(content));\r\n  return content;\r\n};\r\n\r\nmodule.exports = {\r\n  verifySchema,\r\n  checkObjectReferences,\r\n  getPropertiesByString,\r\n  filterWithOperator,\r\n  filterOperators,\r\n  createProperties,\r\n  getInstance,\r\n  concat,\r\n  save,\r\n  read\r\n};\r\n", "const {\r\n  concat,\r\n  verifySchema,\r\n  checkObjectReferences,\r\n  filterWithOperator,\r\n  filterOperators,\r\n  getInstance,\r\n  createProperties,\r\n  save,\r\n  read\r\n} = require('../utils');\r\nconst { existsSync, writeFileSync } = require('fs');\r\n\r\n/**\r\n * It returns an object with functions to manipulate the data in the document\r\n * @param {Object} schema - The schema of the model.\r\n * @param {String} path - The path to the file where the data will be stored.\r\n * @param {Array} schemas - The schemas of the models.\r\n * @param {Boolean} readOnFind - If true, the file will be read every time you call the find function.\r\n * @returns an object with the functions `find`, `create`, `remove`, `update` and `replaceModel`.\r\n */\r\nfunction Methods(schema, path, schemas, readOnFind) {\r\n  if (!existsSync(path)) writeFileSync(path, '[]');\r\n  let Model = read(path);\r\n\r\n  if (!Array.isArray(Model)) Model = [];\r\n\r\n  /**\r\n   * It takes a data object and returns the same data object with some properties added to it\r\n   * @returns The dataWithProperties function is being returned.\r\n   */\r\n  const dataWithProperties = data => {\r\n    const isArray = Array.isArray(data);\r\n    const defineProperties = _data =>\r\n      createProperties(_data, {\r\n        update: values => update({ _id: _data._id }, values),\r\n        remove: () => remove({ _id: _data._id }),\r\n        save: () => saveModel(_data, false)\r\n      });\r\n\r\n    if (isArray) return data.map(data => defineProperties(data));\r\n    else return defineProperties(data);\r\n  };\r\n\r\n  /**\r\n   * It saves a model to a file\r\n   * @param data - The data to save\r\n   * @param {Boolean} push - If true, the data will be pushed to the Model array. If false, the data will\r\n   * be updated in the Model array.\r\n   * @returns The dataWithProperties function is being returned.\r\n   */\r\n  const saveModel = (data, push) => {\r\n    data = verifySchema(data, schema);\r\n\r\n    if (push) Model.unshift(data);\r\n    else {\r\n      const objIndex = Model.findIndex(obj => obj._id === data._id);\r\n\r\n      if (objIndex < 0)\r\n        throw new Error(`Could not find item id ${data._id} to save it`);\r\n\r\n      Model[objIndex] = data;\r\n    }\r\n\r\n    save(path, Model);\r\n\r\n    return dataWithProperties(data);\r\n  };\r\n\r\n  /**\r\n   * It takes a query and a reference, and returns an array of objects that match the query\r\n   * @param query - The query\r\n   * @param ref - The reference\r\n   * @returns The find function is being returned.\r\n   */\r\n  const find = (query, ref) => {\r\n    let findedData = [];\r\n\r\n    const queryType = getInstance(query);\r\n\r\n    if (readOnFind) Model = read(path, true);\r\n\r\n    const defaultAction = () =>\r\n      query ? Model.find(obj => obj._id === query) : Model;\r\n    const operator = filterOperators(query);\r\n\r\n    const getAction = {\r\n      function: () => {\r\n        if (!ref) return Model.filter(query);\r\n        else {\r\n          const queryReferences = Model.filter(query).map(data => {\r\n            const reference = checkObjectReferences(ref, schemas, data);\r\n            return Object.assign(data, reference);\r\n          });\r\n\r\n          return queryReferences;\r\n        }\r\n      },\r\n      object: () => {\r\n        const queryParams =\r\n          operator.rest &&\r\n          Object.entries(operator.rest).some(\r\n            param => getInstance(param[1]) !== 'object'\r\n          );\r\n\r\n        if (queryParams) {\r\n          let findedData = Model || [];\r\n\r\n          for (var filter of Object.entries(operator.rest)) {\r\n            const [key, value] = filter;\r\n            const valueType = getInstance(value);\r\n\r\n            if (['object', 'function'].includes(valueType)) continue;\r\n\r\n            findedData = findedData.filter(obj => obj[key] === value);\r\n          }\r\n\r\n          for (var data of findedData) {\r\n            const queryReferences = checkObjectReferences(query, schemas, data);\r\n            Object.assign(data, queryReferences);\r\n          }\r\n\r\n          return findedData;\r\n        } else {\r\n          const queryReferences = Model.filter(data => {\r\n            const reference = checkObjectReferences(query, schemas, data);\r\n            return Object.assign(data, reference);\r\n          });\r\n\r\n          return queryReferences;\r\n        }\r\n      },\r\n      string: defaultAction,\r\n      number: defaultAction\r\n    };\r\n\r\n    if (\r\n      ['undefined', 'null'].includes(queryType) ||\r\n      (queryType === 'object' && !Object.keys(query)?.length)\r\n    )\r\n      findedData = Model;\r\n    else if (!getAction[queryType]) return [];\r\n    else findedData = getAction[queryType]();\r\n\r\n    if (operator.data)\r\n      findedData = filterWithOperator(findedData, operator.data);\r\n\r\n    return dataWithProperties(findedData);\r\n  };\r\n\r\n  const findOne = (query, ref) => {\r\n    const data = find(query, ref);\r\n\r\n    if (!data) return undefined;\r\n\r\n    const isArray = Array.isArray(data);\r\n\r\n    return isArray ? data[0] : data;\r\n  };\r\n\r\n  /**\r\n   * It creates a new object, checks if it already exists, and then saves it.\r\n   * @returns An object with a save method.\r\n   */\r\n  const create = data => {\r\n    const exists = Model.find(obj => obj._id === data._id);\r\n\r\n    if (exists)\r\n      throw new Error('Duplicate ids. The ids are unique, try another one.');\r\n\r\n    data = verifySchema(data, schema);\r\n\r\n    return {\r\n      save: () => saveModel(data, true)\r\n    };\r\n  };\r\n\r\n  /**\r\n   * It takes a query and values, finds the document, concatenates the values to the document, and\r\n   * returns a save function.\r\n   * @param query - The query to find the document.\r\n   * @param values - The values to update the document with.\r\n   * @returns An object with a save function.\r\n   */\r\n  const update = (query, values) => {\r\n    if (values === undefined)\r\n      throw new Error(\r\n        'The update function requires arguments, see the documentation.'\r\n      );\r\n\r\n    const doc = find(query)?.[0];\r\n\r\n    if (!doc)\r\n      throw new Error('Document not found, update could not be performed.');\r\n\r\n    const data = concat(doc, values, schema);\r\n\r\n    return {\r\n      save: () => saveModel(data, false)\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Remove an object in the document\r\n   *\r\n   * @name remove\r\n   * @param {String|Number|Object|Function} query The query to find the object.\r\n   */\r\n  const remove = query => {\r\n    if (!query)\r\n      throw new Error(\r\n        'The remove function requires arguments, see the documentation.'\r\n      );\r\n\r\n    const queryType = getInstance(query);\r\n\r\n    if (readOnFind) Model = read(path, true);\r\n\r\n    const defaultAction = () => Model.filter(obj => obj._id !== query);\r\n\r\n    const getAction = {\r\n      function: () => Model.filter(obj => !query(obj)),\r\n      object: () => {\r\n        const queryParams = Object.entries(query)?.[0];\r\n        return Model.filter(\r\n          obj => obj?.[queryParams?.[0]] !== queryParams?.[1]\r\n        );\r\n      },\r\n      string: defaultAction,\r\n      number: defaultAction\r\n    };\r\n\r\n    Model = getAction[queryType]();\r\n\r\n    save(path, Model);\r\n  };\r\n\r\n  /**\r\n   * Replaces the current data of a Model\r\n   * BETA VERSION\r\n   *\r\n   * @name replaceModel\r\n   * @param {Object} data The new document to set.\r\n   */\r\n  const replaceModel = data => {\r\n    if (!data)\r\n      console.warn(\r\n        '[db-local] No data was entered to replace the current one, an empty array was defined by default'\r\n      );\r\n\r\n    if (data && !Array.isArray(data))\r\n      throw new Error('The data must be of type Array');\r\n\r\n    Model = data ? data : [];\r\n    save(path, Model);\r\n  };\r\n\r\n  return {\r\n    find,\r\n    findOne,\r\n    create,\r\n    remove,\r\n    update,\r\n    replaceModel\r\n  };\r\n}\r\n\r\nmodule.exports = Methods;\r\n", "\"use strict\";\r\n/**\r\n * Machine id.\r\n *\r\n * Create a random 3-byte value (i.e. unique for this\r\n * process). Other drivers use a md5 of the machine id here, but\r\n * that would mean an asyc call to gethostname, so we don't bother.\r\n * @ignore\r\n */\r\nvar MACHINE_ID = parseInt(Math.random() * 0xffffff, 10);\r\n\r\n// Regular expression that checks for hex value\r\nvar checkForHexRegExp = new RegExp(\"^[0-9a-fA-F]{24}$\");\r\nvar hasBufferType = false;\r\n\r\n// Check if buffer exists\r\ntry {\r\n  if (Buffer && Buffer.from) hasBufferType = true;\r\n} catch (err) {\r\n  hasBufferType = false;\r\n}\r\n\r\n/**\r\n * Create a new ObjectID instance\r\n *\r\n * @class\r\n * @param {(string|number)} id Can be a 24 byte hex string, 12 byte binary string or a Number.\r\n * @property {number} generationTime The generation time of this ObjectId instance\r\n * @return {ObjectID} instance of ObjectID.\r\n */\r\nfunction ObjectID(id) {\r\n  // Duck-typing to support ObjectId from different npm packages\r\n  if (id instanceof ObjectID) return id;\r\n  if (!(this instanceof ObjectID)) return new ObjectID(id);\r\n\r\n  this._bsontype = \"ObjectID\";\r\n\r\n  // The most common usecase (blank id, new objectId instance)\r\n  if (id == null || typeof id === \"number\") {\r\n    // Generate a new id\r\n    this.id = this.generate(id);\r\n    // If we are caching the hex string\r\n    if (ObjectID.cacheHexString) this.__id = this.toString(\"hex\");\r\n    // Return the object\r\n    return;\r\n  }\r\n\r\n  // Check if the passed in id is valid\r\n  var valid = ObjectID.isValid(id);\r\n\r\n  // Throw an error if it's not a valid setup\r\n  if (!valid && id != null) {\r\n    throw new TypeError(\r\n      \"Argument passed in must be a single String of 12 bytes or a string of 24 hex characters\"\r\n    );\r\n  } else if (\r\n    valid &&\r\n    typeof id === \"string\" &&\r\n    id.length === 24 &&\r\n    hasBufferType\r\n  ) {\r\n    return new ObjectID(Buffer.from(id, \"hex\"));\r\n  } else if (valid && typeof id === \"string\" && id.length === 24) {\r\n    return ObjectID.createFromHexString(id);\r\n  } else if (id != null && id.length === 12) {\r\n    // assume 12 byte string\r\n    this.id = id;\r\n  } else if (id != null && id.toHexString) {\r\n    // Duck-typing to support ObjectId from different npm packages\r\n    return id;\r\n  } else {\r\n    throw new TypeError(\r\n      \"Argument passed in must be a single String of 12 bytes or a string of 24 hex characters\"\r\n    );\r\n  }\r\n\r\n  if (ObjectID.cacheHexString) this.__id = this.toString(\"hex\");\r\n}\r\n\r\n// Allow usage of ObjectId as well as ObjectID\r\n// var ObjectId = ObjectID;\r\n\r\n// Precomputed hex table enables speedy hex string conversion\r\nvar hexTable = [];\r\nfor (var i = 0; i < 256; i++) {\r\n  hexTable[i] = (i <= 15 ? \"0\" : \"\") + i.toString(16);\r\n}\r\n\r\n/**\r\n * Return the ObjectID id as a 24 byte hex string representation\r\n *\r\n * @method\r\n * @return {string} return the 24 byte hex string representation.\r\n */\r\nObjectID.prototype.toHexString = function () {\r\n  if (ObjectID.cacheHexString && this.__id) return this.__id;\r\n\r\n  var hexString = \"\";\r\n  if (!this.id || !this.id.length) {\r\n    throw new TypeError(\r\n      \"invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [\" +\r\n        JSON.stringify(this.id) +\r\n        \"]\"\r\n    );\r\n  }\r\n\r\n  if (this.id instanceof _Buffer) {\r\n    hexString = convertToHex(this.id);\r\n    if (ObjectID.cacheHexString) this.__id = hexString;\r\n    return hexString;\r\n  }\r\n\r\n  for (var i = 0; i < this.id.length; i++) {\r\n    hexString += hexTable[this.id.charCodeAt(i)];\r\n  }\r\n\r\n  if (ObjectID.cacheHexString) this.__id = hexString;\r\n  return hexString;\r\n};\r\n\r\n/**\r\n * Update the ObjectID index used in generating new ObjectID's on the driver\r\n *\r\n * @method\r\n * @return {number} returns next index value.\r\n * @ignore\r\n */\r\nObjectID.prototype.get_inc = function () {\r\n  return (ObjectID.index = (ObjectID.index + 1) % 0xffffff);\r\n};\r\n\r\n/**\r\n * Update the ObjectID index used in generating new ObjectID's on the driver\r\n *\r\n * @method\r\n * @return {number} returns next index value.\r\n * @ignore\r\n */\r\nObjectID.prototype.getInc = function () {\r\n  return this.get_inc();\r\n};\r\n\r\n/**\r\n * Generate a 12 byte id buffer used in ObjectID's\r\n *\r\n * @method\r\n * @param {number} [time] optional parameter allowing to pass in a second based timestamp.\r\n * @return {Buffer} return the 12 byte id buffer string.\r\n */\r\nObjectID.prototype.generate = function (time) {\r\n  if (\"number\" !== typeof time) {\r\n    time = ~~(Date.now() / 1000);\r\n  }\r\n\r\n  // Use pid\r\n  var pid =\r\n    (typeof process === \"undefined\" || process.pid === 1\r\n      ? Math.floor(Math.random() * 100000)\r\n      : process.pid) % 0xffff;\r\n  var inc = this.get_inc();\r\n  // Buffer used\r\n  var buffer = Buffer.alloc(12);\r\n  // Encode time\r\n  buffer[3] = time & 0xff;\r\n  buffer[2] = (time >> 8) & 0xff;\r\n  buffer[1] = (time >> 16) & 0xff;\r\n  buffer[0] = (time >> 24) & 0xff;\r\n  // Encode machine\r\n  buffer[6] = MACHINE_ID & 0xff;\r\n  buffer[5] = (MACHINE_ID >> 8) & 0xff;\r\n  buffer[4] = (MACHINE_ID >> 16) & 0xff;\r\n  // Encode pid\r\n  buffer[8] = pid & 0xff;\r\n  buffer[7] = (pid >> 8) & 0xff;\r\n  // Encode index\r\n  buffer[11] = inc & 0xff;\r\n  buffer[10] = (inc >> 8) & 0xff;\r\n  buffer[9] = (inc >> 16) & 0xff;\r\n  // Return the buffer\r\n  return buffer;\r\n};\r\n\r\n/**\r\n * Converts the id into a 24 byte hex string for printing\r\n *\r\n * @param {String} format The Buffer toString format parameter.\r\n * @return {String} return the 24 byte hex string representation.\r\n * @ignore\r\n */\r\nObjectID.prototype.toString = function (format) {\r\n  // Is the id a buffer then use the buffer toString method to return the format\r\n  if (this.id && this.id.copy) {\r\n    return this.id.toString(typeof format === \"string\" ? format : \"hex\");\r\n  }\r\n\r\n  // if(this.buffer )\r\n  return this.toHexString();\r\n};\r\n\r\n/**\r\n * Converts to a string representation of this Id.\r\n *\r\n * @return {String} return the 24 byte hex string representation.\r\n * @ignore\r\n */\r\nObjectID.prototype.inspect = ObjectID.prototype.toString;\r\n\r\n/**\r\n * Converts to its JSON representation.\r\n *\r\n * @return {String} return the 24 byte hex string representation.\r\n * @ignore\r\n */\r\nObjectID.prototype.toJSON = function () {\r\n  return this.toHexString();\r\n};\r\n\r\n/**\r\n * Compares the equality of this ObjectID with `otherID`.\r\n *\r\n * @method\r\n * @param {object} otherID ObjectID instance to compare against.\r\n * @return {boolean} the result of comparing two ObjectID's\r\n */\r\nObjectID.prototype.equals = function equals(otherId) {\r\n  if (otherId instanceof ObjectID) {\r\n    return this.toString() === otherId.toString();\r\n  } else if (\r\n    typeof otherId === \"string\" &&\r\n    ObjectID.isValid(otherId) &&\r\n    otherId.length === 12 &&\r\n    this.id instanceof _Buffer\r\n  ) {\r\n    return otherId === this.id.toString(\"binary\");\r\n  } else if (\r\n    typeof otherId === \"string\" &&\r\n    ObjectID.isValid(otherId) &&\r\n    otherId.length === 24\r\n  ) {\r\n    return otherId.toLowerCase() === this.toHexString();\r\n  } else if (\r\n    typeof otherId === \"string\" &&\r\n    ObjectID.isValid(otherId) &&\r\n    otherId.length === 12\r\n  ) {\r\n    return otherId === this.id;\r\n  } else if (\r\n    otherId != null &&\r\n    (otherId instanceof ObjectID || otherId.toHexString)\r\n  ) {\r\n    return otherId.toHexString() === this.toHexString();\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Returns the generation date (accurate up to the second) that this ID was generated.\r\n *\r\n * @method\r\n * @return {date} the generation date\r\n */\r\nObjectID.prototype.getTimestamp = function () {\r\n  var timestamp = new Date();\r\n  var time =\r\n    this.id[3] | (this.id[2] << 8) | (this.id[1] << 16) | (this.id[0] << 24);\r\n  timestamp.setTime(Math.floor(time) * 1000);\r\n  return timestamp;\r\n};\r\n\r\n/**\r\n * @ignore\r\n */\r\nObjectID.index = ~~(Math.random() * 0xffffff);\r\n\r\n/**\r\n * @ignore\r\n */\r\nObjectID.createPk = function createPk() {\r\n  return new ObjectID();\r\n};\r\n\r\n/**\r\n * Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.\r\n *\r\n * @method\r\n * @param {number} time an integer number representing a number of seconds.\r\n * @return {ObjectID} return the created ObjectID\r\n */\r\nObjectID.createFromTime = function createFromTime(time) {\r\n  var buffer = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\r\n  // Encode time into first 4 bytes\r\n  buffer[3] = time & 0xff;\r\n  buffer[2] = (time >> 8) & 0xff;\r\n  buffer[1] = (time >> 16) & 0xff;\r\n  buffer[0] = (time >> 24) & 0xff;\r\n  // Return the new objectId\r\n  return new ObjectID(buffer);\r\n};\r\n\r\n// Lookup tables\r\nvar decodeLookup = [];\r\ni = 0;\r\nwhile (i < 10) decodeLookup[0x30 + i] = i++;\r\nwhile (i < 16) decodeLookup[0x41 - 10 + i] = decodeLookup[0x61 - 10 + i] = i++;\r\n\r\nvar _Buffer = Buffer;\r\nvar convertToHex = function (bytes) {\r\n  return bytes.toString(\"hex\");\r\n};\r\n\r\n/**\r\n * Creates an ObjectID from a hex string representation of an ObjectID.\r\n *\r\n * @method\r\n * @param {string} hexString create a ObjectID from a passed in 24 byte hexstring.\r\n * @return {ObjectID} return the created ObjectID\r\n */\r\nObjectID.createFromHexString = function createFromHexString(string) {\r\n  // Throw an error if it's not a valid setup\r\n  if (\r\n    typeof string === \"undefined\" ||\r\n    (string != null && string.length !== 24)\r\n  ) {\r\n    throw new TypeError(\r\n      \"Argument passed in must be a single String of 12 bytes or a string of 24 hex characters\"\r\n    );\r\n  }\r\n\r\n  // Use Buffer.from method if available\r\n  if (hasBufferType) return new ObjectID(Buffer.from(string, \"hex\"));\r\n\r\n  // Calculate lengths\r\n  var array = new _Buffer(12);\r\n  var n = 0;\r\n  var i = 0;\r\n\r\n  while (i < 24) {\r\n    array[n++] =\r\n      (decodeLookup[string.charCodeAt(i++)] << 4) |\r\n      decodeLookup[string.charCodeAt(i++)];\r\n  }\r\n\r\n  return new ObjectID(array);\r\n};\r\n\r\n/**\r\n * Checks if a value is a valid bson ObjectId\r\n *\r\n * @method\r\n * @return {boolean} return true if the value is a valid bson ObjectId, return false otherwise.\r\n */\r\nObjectID.isValid = function isValid(id) {\r\n  if (id == null) return false;\r\n\r\n  if (typeof id === \"number\") {\r\n    return true;\r\n  }\r\n\r\n  if (typeof id === \"string\") {\r\n    return id.length === 12 || (id.length === 24 && checkForHexRegExp.test(id));\r\n  }\r\n\r\n  if (id instanceof ObjectID) {\r\n    return true;\r\n  }\r\n\r\n  if (id instanceof _Buffer) {\r\n    return true;\r\n  }\r\n\r\n  // Duck-Typing detection of ObjectId like objects\r\n  if (id.toHexString) {\r\n    return (\r\n      id.id.length === 12 ||\r\n      (id.id.length === 24 && checkForHexRegExp.test(id.id))\r\n    );\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * @ignore\r\n */\r\nObject.defineProperty(ObjectID.prototype, \"generationTime\", {\r\n  enumerable: true,\r\n  get: function () {\r\n    return (\r\n      this.id[3] | (this.id[2] << 8) | (this.id[1] << 16) | (this.id[0] << 24)\r\n    );\r\n  },\r\n  set: function (value) {\r\n    // Encode time into first 4 bytes\r\n    this.id[3] = value & 0xff;\r\n    this.id[2] = (value >> 8) & 0xff;\r\n    this.id[1] = (value >> 16) & 0xff;\r\n    this.id[0] = (value >> 24) & 0xff;\r\n  },\r\n});\r\n\r\n/**\r\n * Expose.\r\n */\r\nmodule.exports = ObjectID;\r\nmodule.exports.ObjectID = ObjectID;\r\nmodule.exports.ObjectId = ObjectID;\r\n", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"path\" has been externalized for browser compatibility. Cannot access \"path.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "const Methods = require(\"./methods\");\r\nconst { ObjectId } = require(\"./objectid\");\r\n\r\nconst { resolve } = require(\"path\");\r\n\r\nconst defaultId = {\r\n  type: String,\r\n  default: () => new ObjectId().toString(),\r\n  required: true\r\n};\r\nconst schemas = {};\r\n\r\n/**\r\n * It takes a model name, a schema, a path to the database, and a boolean to determine if the database\r\n * should be read on find\r\n * @param {Object} model - The name of the model.\r\n * @param {Object} schema - The schema of the model.\r\n * @param {String} path - The path to the database folder.\r\n * @param {Boolean} readOnFind - If true, the database will be read on every find() call.\r\n * @returns The return value is an object with the methods that are defined in the Methods function.\r\n */\r\nfunction Schema(model, schema = { _id: defaultId }, path, readOnFind) {\r\n  if (!model)\r\n    throw new Error(\"The Schema requires a name, see the documentation.\");\r\n\r\n  if (!schema._id) schema._id = defaultId;\r\n\r\n  const schemaIdType =\r\n    typeof schema._id === \"object\" ? schema._id.type : schema._id;\r\n\r\n  if (\r\n    ![Number, String].includes(schemaIdType) ||\r\n    (typeof schema._id === \"function\" && schemaIdType === String) ||\r\n    (typeof schema._id === \"object\" &&\r\n      schemaIdType === String &&\r\n      !schema._id.default)\r\n  )\r\n    schema._id = defaultId;\r\n\r\n  if (schema._id.required === undefined) schema._id.required = true;\r\n\r\n  const databasePath = resolve(`${path}/${model}.json`);\r\n\r\n  schemas[model] = { path: databasePath, schema };\r\n\r\n  return {\r\n    ...Methods(schema, databasePath, schemas, readOnFind)\r\n  };\r\n}\r\n\r\nmodule.exports = Schema;\r\n", "const Schema = require(\"./modules/schema\");\r\nconst { resolve } = require(\"path\");\r\nconst { existsSync, mkdirSync } = require(\"fs\");\r\nconst { ObjectId } = require(\"./modules/objectid\");\r\n\r\n/**\r\n * It creates a database object with a Schema function and a Types object\r\n * @param {String} path - The path to the directory where the database files will be stored.\r\n * @param {Boolean} readOnFind - If true, the database will be read on every find() call.\r\n * @default { path: './databases', readOnFind: false }\r\n * @returns An object with two properties: Schema and Types.\r\n */\r\nfunction dbLocal(\r\n  { path, readOnFind } = { path: \"./databases\", readOnFind: false }\r\n) {\r\n  const databasePath = resolve(path);\r\n  if (!existsSync(databasePath)) mkdirSync(databasePath);\r\n\r\n  return {\r\n    Schema: (model, schema) => Schema(model, schema, path, readOnFind),\r\n    Types: {\r\n      ObjectId: () => new ObjectId().toString()\r\n    }\r\n  };\r\n}\r\n\r\nmodule.exports = dbLocal;\r\n"],
  "mappings": "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",
  "names": ["data", "notOperators", "index", "obj", "data", "findedData", "i"]
}
