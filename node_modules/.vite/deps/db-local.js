import {
  __commonJS,
  __require
} from "./chunk-VUNV25KB.js";

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/db-local@3.1.0/node_modules/db-local/lib/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/db-local@3.1.0/node_modules/db-local/lib/utils.js"(exports, module) {
    var { writeFileSync } = require_fs();
    function getInstance(value) {
      const type = typeof value;
      return type === "object" || type === "function" ? Object.prototype.toString.call(value).slice(8, -1).toLowerCase() : type;
    }
    function verifySchema(obj, schema) {
      const defined = {};
      for (const [key, data] of Object.entries(schema)) {
        const value = obj == null ? void 0 : obj[key];
        const type = typeof data === "function" ? data : (data == null ? void 0 : data.type) || data;
        if (!type)
          throw new Error(`The value "${key}" does not have a defined type.`);
        const instanceOfValue = getInstance(value);
        const instanceOfType = getInstance(type);
        const instanceOfTypeFunction = instanceOfType === "function" && getInstance(type());
        if (["null", "undefined"].includes(instanceOfType))
          throw new Error(`The value "${key}" has an invalid type.`);
        const hasDefault = (data == null ? void 0 : data.default) !== void 0;
        const hasNullable = (data == null ? void 0 : data.nullable) !== void 0;
        const isUndefinedOrNull = ["undefined", "null"].includes(instanceOfValue);
        if (instanceOfValue === "undefined") {
          if (!hasDefault && (data == null ? void 0 : data.required))
            throw new Error(`The value "${key}" is required.`);
          if (hasDefault)
            defined[key] = typeof data.default === "function" ? data.default() : data.default;
          else defined[key] = void 0;
          continue;
        }
        if (instanceOfValue === "null" && !hasNullable)
          throw new Error(`The value "${key}" cannot be null.`);
        if ((data == null ? void 0 : data.enum) && !data.enum.includes(value))
          throw new Error(
            `The value "${key}" must be one of the following values: ${data.enum.join(
              ", "
            )}.`
          );
        switch (instanceOfType) {
          case "function": {
            if (instanceOfTypeFunction && instanceOfValue !== instanceOfTypeFunction)
              throw new Error(
                `The value "${key}" must be an instance of ${type.name}.`
              );
            else defined[key] = value;
            break;
          }
          case "object": {
            if (!isUndefinedOrNull) defined[key] = verifySchema(value, type);
            break;
          }
          case "array": {
            if (instanceOfValue === "array")
              defined[key] = value.map((item) => {
                var _a, _b;
                const instanceOfItem = getInstance(item);
                const instanceOfTypeItem = getInstance(
                  typeof type[0] === "function" ? type[0]() : (_a = type[0]) == null ? void 0 : _a.type()
                );
                if (instanceOfItem === "object") return verifySchema(item, type[0]);
                if (instanceOfItem !== instanceOfTypeItem && !((_b = type[0]) == null ? void 0 : _b.nullable))
                  throw new Error(
                    `The value "${key}" must be an Array of the type ${instanceOfTypeItem} and has received a item of type ${instanceOfItem}.`
                  );
                return item;
              });
            break;
          }
          default: {
            if (instanceOfValue !== instanceOfType)
              throw new Error(
                `The value "${key}" must be an instance of ${instanceOfType}.`
              );
            defined[key] = value;
            break;
          }
        }
      }
      return defined;
    }
    function concat(obj, entries, schema) {
      const defined = { ...obj };
      Object.entries(entries).forEach((r) => {
        Object.entries(defined).filter((a) => {
          if (a[0] === r[0] && r[1] != a[1]) defined[a[0]] = r[1];
          else if (r[0]) defined[r[0]] = r[1];
        });
      });
      return verifySchema(defined, schema);
    }
    var getPropertiesByString = (obj, string) => string.split(".").reduce((o, i) => o == null ? void 0 : o[i], obj);
    function filterWithOperator(data, operators) {
      const props = (...args) => getPropertiesByString(...args);
      if (!data) return null;
      const filters = {
        $gt: (obj, key, value) => props(obj, key) > value,
        $lt: (obj, key, value) => props(obj, key) < value,
        $gte: (obj, key, value) => props(obj, key) >= value,
        $lte: (obj, key, value) => props(obj, key) <= value,
        $eq: (obj, key, value) => props(obj, key) === value,
        $neq: (obj, key, value) => props(obj, key) !== value,
        $in: (obj, key, value) => {
          if (Array.isArray(value)) return value.some((a) => props(obj, key).includes(a));
          else return props(obj, key).includes(value);
        },
        $nin: (obj, key, value) => {
          if (Array.isArray(value)) return value.every((a) => !props(obj, key).includes(a));
          else return !props(obj, key).includes(value);
        },
        $regex: (obj, key, value) => props(obj, key).match(value),
        $exists: (obj, key) => props(obj, key) !== void 0
      };
      const limit = operators == null ? void 0 : operators.$limit;
      operators = Object.keys(operators).filter((a) => !["$id", "$ref"].includes(a)).reduce((acc, key) => {
        const data2 = operators[key];
        for (const operator in data2) {
          const value = data2[operator];
          if (value && filters[operator] && (typeof value === "object" ? Array.isArray(value) : true))
            acc.push({ operator, value, key });
        }
        return acc;
      }, []);
      for (var filter of operators) {
        const { operator, value, key } = filter;
        data = data.filter((obj) => filters[operator](obj, key, value));
      }
      if (typeof limit === "number" && limit >= 1) {
        if (!Array.isArray(data)) data = [data];
        if (limit === 1) {
          if (data.length) return data[0];
          else return null;
        } else return data.slice(0, limit);
      } else {
        return data;
      }
    }
    function filterOperators(data) {
      const filter = (index) => {
        const notOperators2 = ["$id", "$ref"];
        const customOperators = ["$limit"];
        if (notOperators2.includes(index) || !["object", "string"].includes(typeof data))
          return false;
        if (customOperators.includes(index)) return true;
        else if (typeof data[index] === "string") return data[index].includes("$");
        else if (typeof data[index] === "object")
          return Object.keys(data[index]).some(
            (index2) => index2.includes("$") && !notOperators2.includes(index2)
          );
      };
      if (typeof data !== "object")
        return {
          data: false,
          rest: data
        };
      const operators = Object.keys(data).filter(filter);
      const notOperators = Object.keys(data).filter((index) => !filter(index));
      const result = {
        data: operators.length ? {} : false,
        rest: notOperators.length ? {} : false
      };
      for (var operator of operators) result.data[operator] = data[operator];
      for (var rest of notOperators) result.rest[rest] = data[rest];
      return result;
    }
    function checkObjectReferences(obj, schemas, baseData) {
      var _a, _b;
      const defined = {};
      for (const key of Object.keys(obj)) {
        if (((_a = obj[key]) == null ? void 0 : _a.$ref) && ((_b = obj[key]) == null ? void 0 : _b.$id)) {
          const { $id, $ref } = obj[key];
          const refSchema = schemas[$ref];
          const model = read(refSchema.path);
          let propertyRef, data;
          const multipleFind = (obj2) => Array.isArray(propertyRef) ? propertyRef.includes(obj2._id) : obj2._id === propertyRef;
          const defaultAction = (id) => model.find((obj2) => obj2._id === id);
          if (!refSchema) throw new Error(`The "${$ref}" schema is not defined`);
          if (typeof $id === "number" || typeof $id === "string" && !$id.includes("$data")) {
            data = defaultAction($id);
          } else {
            propertyRef = getPropertiesByString(
              baseData,
              typeof $id === "string" ? $id == null ? void 0 : $id.replace("$data.", "") : $id.$data
            );
            data = model[Array.isArray(propertyRef) ? "filter" : "find"](multipleFind);
          }
          const operators = filterOperators(obj[key]);
          defined[key] = operators.data ? filterWithOperator(data, operators.data) : data;
        }
      }
      return defined;
    }
    function createProperties(data, properties) {
      const getPropertyConfig = (val) => ({
        get: () => val,
        enumerable: false,
        configurable: true
      });
      for (var property of Object.entries(properties)) {
        const [key, value] = property;
        const valueType = getInstance(value);
        if (valueType === "function")
          properties[key] = getPropertyConfig(value.bind(data));
        else properties[key] = getPropertyConfig(value);
      }
      Object.defineProperties(data, properties);
      return data;
    }
    var read = (path, clear) => {
      if (clear) delete __require.cache[__require.resolve(path)];
      return __require(path);
    };
    var save = (path, content) => {
      writeFileSync(path, JSON.stringify(content));
      return content;
    };
    module.exports = {
      verifySchema,
      checkObjectReferences,
      getPropertiesByString,
      filterWithOperator,
      filterOperators,
      createProperties,
      getInstance,
      concat,
      save,
      read
    };
  }
});

// node_modules/.pnpm/db-local@3.1.0/node_modules/db-local/lib/modules/methods.js
var require_methods = __commonJS({
  "node_modules/.pnpm/db-local@3.1.0/node_modules/db-local/lib/modules/methods.js"(exports, module) {
    var {
      concat,
      verifySchema,
      checkObjectReferences,
      filterWithOperator,
      filterOperators,
      getInstance,
      createProperties,
      save,
      read
    } = require_utils();
    var { existsSync, writeFileSync } = require_fs();
    function Methods(schema, path, schemas, readOnFind) {
      if (!existsSync(path)) writeFileSync(path, "[]");
      let Model = read(path);
      if (!Array.isArray(Model)) Model = [];
      const dataWithProperties = (data) => {
        const isArray = Array.isArray(data);
        const defineProperties = (_data) => createProperties(_data, {
          update: (values) => update({ _id: _data._id }, values),
          remove: () => remove({ _id: _data._id }),
          save: () => saveModel(_data, false)
        });
        if (isArray) return data.map((data2) => defineProperties(data2));
        else return defineProperties(data);
      };
      const saveModel = (data, push) => {
        data = verifySchema(data, schema);
        if (push) Model.unshift(data);
        else {
          const objIndex = Model.findIndex((obj) => obj._id === data._id);
          if (objIndex < 0)
            throw new Error(`Could not find item id ${data._id} to save it`);
          Model[objIndex] = data;
        }
        save(path, Model);
        return dataWithProperties(data);
      };
      const find = (query, ref) => {
        var _a;
        let findedData = [];
        const queryType = getInstance(query);
        if (readOnFind) Model = read(path, true);
        const defaultAction = () => query ? Model.find((obj) => obj._id === query) : Model;
        const operator = filterOperators(query);
        const getAction = {
          function: () => {
            if (!ref) return Model.filter(query);
            else {
              const queryReferences = Model.filter(query).map((data) => {
                const reference = checkObjectReferences(ref, schemas, data);
                return Object.assign(data, reference);
              });
              return queryReferences;
            }
          },
          object: () => {
            const queryParams = operator.rest && Object.entries(operator.rest).some(
              (param) => getInstance(param[1]) !== "object"
            );
            if (queryParams) {
              let findedData2 = Model || [];
              for (var filter of Object.entries(operator.rest)) {
                const [key, value] = filter;
                const valueType = getInstance(value);
                if (["object", "function"].includes(valueType)) continue;
                findedData2 = findedData2.filter((obj) => obj[key] === value);
              }
              for (var data of findedData2) {
                const queryReferences = checkObjectReferences(query, schemas, data);
                Object.assign(data, queryReferences);
              }
              return findedData2;
            } else {
              const queryReferences = Model.filter((data2) => {
                const reference = checkObjectReferences(query, schemas, data2);
                return Object.assign(data2, reference);
              });
              return queryReferences;
            }
          },
          string: defaultAction,
          number: defaultAction
        };
        if (["undefined", "null"].includes(queryType) || queryType === "object" && !((_a = Object.keys(query)) == null ? void 0 : _a.length))
          findedData = Model;
        else if (!getAction[queryType]) return [];
        else findedData = getAction[queryType]();
        if (operator.data)
          findedData = filterWithOperator(findedData, operator.data);
        return dataWithProperties(findedData);
      };
      const findOne = (query, ref) => {
        const data = find(query, ref);
        if (!data) return void 0;
        const isArray = Array.isArray(data);
        return isArray ? data[0] : data;
      };
      const create = (data) => {
        const exists = Model.find((obj) => obj._id === data._id);
        if (exists)
          throw new Error("Duplicate ids. The ids are unique, try another one.");
        data = verifySchema(data, schema);
        return {
          save: () => saveModel(data, true)
        };
      };
      const update = (query, values) => {
        var _a;
        if (values === void 0)
          throw new Error(
            "The update function requires arguments, see the documentation."
          );
        const doc = (_a = find(query)) == null ? void 0 : _a[0];
        if (!doc)
          throw new Error("Document not found, update could not be performed.");
        const data = concat(doc, values, schema);
        return {
          save: () => saveModel(data, false)
        };
      };
      const remove = (query) => {
        if (!query)
          throw new Error(
            "The remove function requires arguments, see the documentation."
          );
        const queryType = getInstance(query);
        if (readOnFind) Model = read(path, true);
        const defaultAction = () => Model.filter((obj) => obj._id !== query);
        const getAction = {
          function: () => Model.filter((obj) => !query(obj)),
          object: () => {
            var _a;
            const queryParams = (_a = Object.entries(query)) == null ? void 0 : _a[0];
            return Model.filter(
              (obj) => (obj == null ? void 0 : obj[queryParams == null ? void 0 : queryParams[0]]) !== (queryParams == null ? void 0 : queryParams[1])
            );
          },
          string: defaultAction,
          number: defaultAction
        };
        Model = getAction[queryType]();
        save(path, Model);
      };
      const replaceModel = (data) => {
        if (!data)
          console.warn(
            "[db-local] No data was entered to replace the current one, an empty array was defined by default"
          );
        if (data && !Array.isArray(data))
          throw new Error("The data must be of type Array");
        Model = data ? data : [];
        save(path, Model);
      };
      return {
        find,
        findOne,
        create,
        remove,
        update,
        replaceModel
      };
    }
    module.exports = Methods;
  }
});

// node_modules/.pnpm/db-local@3.1.0/node_modules/db-local/lib/modules/objectid.js
var require_objectid = __commonJS({
  "node_modules/.pnpm/db-local@3.1.0/node_modules/db-local/lib/modules/objectid.js"(exports, module) {
    "use strict";
    var MACHINE_ID = parseInt(Math.random() * 16777215, 10);
    var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
    var hasBufferType = false;
    try {
      if (Buffer && Buffer.from) hasBufferType = true;
    } catch (err) {
      hasBufferType = false;
    }
    function ObjectID(id) {
      if (id instanceof ObjectID) return id;
      if (!(this instanceof ObjectID)) return new ObjectID(id);
      this._bsontype = "ObjectID";
      if (id == null || typeof id === "number") {
        this.id = this.generate(id);
        if (ObjectID.cacheHexString) this.__id = this.toString("hex");
        return;
      }
      var valid = ObjectID.isValid(id);
      if (!valid && id != null) {
        throw new TypeError(
          "Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"
        );
      } else if (valid && typeof id === "string" && id.length === 24 && hasBufferType) {
        return new ObjectID(Buffer.from(id, "hex"));
      } else if (valid && typeof id === "string" && id.length === 24) {
        return ObjectID.createFromHexString(id);
      } else if (id != null && id.length === 12) {
        this.id = id;
      } else if (id != null && id.toHexString) {
        return id;
      } else {
        throw new TypeError(
          "Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"
        );
      }
      if (ObjectID.cacheHexString) this.__id = this.toString("hex");
    }
    var hexTable = [];
    for (i = 0; i < 256; i++) {
      hexTable[i] = (i <= 15 ? "0" : "") + i.toString(16);
    }
    var i;
    ObjectID.prototype.toHexString = function() {
      if (ObjectID.cacheHexString && this.__id) return this.__id;
      var hexString = "";
      if (!this.id || !this.id.length) {
        throw new TypeError(
          "invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [" + JSON.stringify(this.id) + "]"
        );
      }
      if (this.id instanceof _Buffer) {
        hexString = convertToHex(this.id);
        if (ObjectID.cacheHexString) this.__id = hexString;
        return hexString;
      }
      for (var i2 = 0; i2 < this.id.length; i2++) {
        hexString += hexTable[this.id.charCodeAt(i2)];
      }
      if (ObjectID.cacheHexString) this.__id = hexString;
      return hexString;
    };
    ObjectID.prototype.get_inc = function() {
      return ObjectID.index = (ObjectID.index + 1) % 16777215;
    };
    ObjectID.prototype.getInc = function() {
      return this.get_inc();
    };
    ObjectID.prototype.generate = function(time) {
      if ("number" !== typeof time) {
        time = ~~(Date.now() / 1e3);
      }
      var pid = (typeof process === "undefined" || process.pid === 1 ? Math.floor(Math.random() * 1e5) : process.pid) % 65535;
      var inc = this.get_inc();
      var buffer = Buffer.alloc(12);
      buffer[3] = time & 255;
      buffer[2] = time >> 8 & 255;
      buffer[1] = time >> 16 & 255;
      buffer[0] = time >> 24 & 255;
      buffer[6] = MACHINE_ID & 255;
      buffer[5] = MACHINE_ID >> 8 & 255;
      buffer[4] = MACHINE_ID >> 16 & 255;
      buffer[8] = pid & 255;
      buffer[7] = pid >> 8 & 255;
      buffer[11] = inc & 255;
      buffer[10] = inc >> 8 & 255;
      buffer[9] = inc >> 16 & 255;
      return buffer;
    };
    ObjectID.prototype.toString = function(format) {
      if (this.id && this.id.copy) {
        return this.id.toString(typeof format === "string" ? format : "hex");
      }
      return this.toHexString();
    };
    ObjectID.prototype.inspect = ObjectID.prototype.toString;
    ObjectID.prototype.toJSON = function() {
      return this.toHexString();
    };
    ObjectID.prototype.equals = function equals(otherId) {
      if (otherId instanceof ObjectID) {
        return this.toString() === otherId.toString();
      } else if (typeof otherId === "string" && ObjectID.isValid(otherId) && otherId.length === 12 && this.id instanceof _Buffer) {
        return otherId === this.id.toString("binary");
      } else if (typeof otherId === "string" && ObjectID.isValid(otherId) && otherId.length === 24) {
        return otherId.toLowerCase() === this.toHexString();
      } else if (typeof otherId === "string" && ObjectID.isValid(otherId) && otherId.length === 12) {
        return otherId === this.id;
      } else if (otherId != null && (otherId instanceof ObjectID || otherId.toHexString)) {
        return otherId.toHexString() === this.toHexString();
      } else {
        return false;
      }
    };
    ObjectID.prototype.getTimestamp = function() {
      var timestamp = /* @__PURE__ */ new Date();
      var time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
      timestamp.setTime(Math.floor(time) * 1e3);
      return timestamp;
    };
    ObjectID.index = ~~(Math.random() * 16777215);
    ObjectID.createPk = function createPk() {
      return new ObjectID();
    };
    ObjectID.createFromTime = function createFromTime(time) {
      var buffer = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      buffer[3] = time & 255;
      buffer[2] = time >> 8 & 255;
      buffer[1] = time >> 16 & 255;
      buffer[0] = time >> 24 & 255;
      return new ObjectID(buffer);
    };
    var decodeLookup = [];
    i = 0;
    while (i < 10) decodeLookup[48 + i] = i++;
    while (i < 16) decodeLookup[65 - 10 + i] = decodeLookup[97 - 10 + i] = i++;
    var _Buffer = Buffer;
    var convertToHex = function(bytes) {
      return bytes.toString("hex");
    };
    ObjectID.createFromHexString = function createFromHexString(string) {
      if (typeof string === "undefined" || string != null && string.length !== 24) {
        throw new TypeError(
          "Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"
        );
      }
      if (hasBufferType) return new ObjectID(Buffer.from(string, "hex"));
      var array = new _Buffer(12);
      var n = 0;
      var i2 = 0;
      while (i2 < 24) {
        array[n++] = decodeLookup[string.charCodeAt(i2++)] << 4 | decodeLookup[string.charCodeAt(i2++)];
      }
      return new ObjectID(array);
    };
    ObjectID.isValid = function isValid(id) {
      if (id == null) return false;
      if (typeof id === "number") {
        return true;
      }
      if (typeof id === "string") {
        return id.length === 12 || id.length === 24 && checkForHexRegExp.test(id);
      }
      if (id instanceof ObjectID) {
        return true;
      }
      if (id instanceof _Buffer) {
        return true;
      }
      if (id.toHexString) {
        return id.id.length === 12 || id.id.length === 24 && checkForHexRegExp.test(id.id);
      }
      return false;
    };
    Object.defineProperty(ObjectID.prototype, "generationTime", {
      enumerable: true,
      get: function() {
        return this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
      },
      set: function(value) {
        this.id[3] = value & 255;
        this.id[2] = value >> 8 & 255;
        this.id[1] = value >> 16 & 255;
        this.id[0] = value >> 24 & 255;
      }
    });
    module.exports = ObjectID;
    module.exports.ObjectID = ObjectID;
    module.exports.ObjectId = ObjectID;
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/db-local@3.1.0/node_modules/db-local/lib/modules/schema.js
var require_schema = __commonJS({
  "node_modules/.pnpm/db-local@3.1.0/node_modules/db-local/lib/modules/schema.js"(exports, module) {
    var Methods = require_methods();
    var { ObjectId } = require_objectid();
    var { resolve } = require_path();
    var defaultId = {
      type: String,
      default: () => new ObjectId().toString(),
      required: true
    };
    var schemas = {};
    function Schema(model, schema = { _id: defaultId }, path, readOnFind) {
      if (!model)
        throw new Error("The Schema requires a name, see the documentation.");
      if (!schema._id) schema._id = defaultId;
      const schemaIdType = typeof schema._id === "object" ? schema._id.type : schema._id;
      if (![Number, String].includes(schemaIdType) || typeof schema._id === "function" && schemaIdType === String || typeof schema._id === "object" && schemaIdType === String && !schema._id.default)
        schema._id = defaultId;
      if (schema._id.required === void 0) schema._id.required = true;
      const databasePath = resolve(`${path}/${model}.json`);
      schemas[model] = { path: databasePath, schema };
      return {
        ...Methods(schema, databasePath, schemas, readOnFind)
      };
    }
    module.exports = Schema;
  }
});

// node_modules/.pnpm/db-local@3.1.0/node_modules/db-local/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/db-local@3.1.0/node_modules/db-local/lib/index.js"(exports, module) {
    var Schema = require_schema();
    var { resolve } = require_path();
    var { existsSync, mkdirSync } = require_fs();
    var { ObjectId } = require_objectid();
    function dbLocal({ path, readOnFind } = { path: "./databases", readOnFind: false }) {
      const databasePath = resolve(path);
      if (!existsSync(databasePath)) mkdirSync(databasePath);
      return {
        Schema: (model, schema) => Schema(model, schema, path, readOnFind),
        Types: {
          ObjectId: () => new ObjectId().toString()
        }
      };
    }
    module.exports = dbLocal;
  }
});
export default require_lib();
//# sourceMappingURL=db-local.js.map
